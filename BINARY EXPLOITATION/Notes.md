  for example we have the stack 
in that , the rsp is the stack pointer which points towards the top of the stack and the rbp is the base pointer which points towards the base of the stack . 




















![[Pasted image 20250813222635.png]]

this is the epilogue , whree the three things happen at the left top . where the rsp points where the rbp points and then when pop rbp , it will points again the base of the stack ret will point the mov eax,10

## buffer overflow:

![[Pasted image 20250818233256.png]]


## To calculate the offset of the RIP :

---->the first method : we used to calculate the RIP , we do first generate the cyclic text using the pwn tools and then  run the file using the gdb and paste the generated text and then see the info stack and copy the second address and then using the cyclic_find(paste the add)---> ad then the offset of the RIP known

**the second method** is the calculate the offset of the RBP using the above method , and then add the +8 to the RBP , we can know the offset of  the RIP

## why we use the cyclic generated text :

we use the cyclic generated text because the cyclic generated pattern is the pattern generated , not repeated like aaaabaaacaaadaaaeaaafaaagaaahaaa... . so , if the saved RIP get overwritten the
RIP = 0x61616163 ('caaa' in ASCII) using the bytes we can calculated the offset of the RIP

### ğŸ”¹  **RELRO (Relocation Read-Only)**

Relocation Read-Only protects the **GOT (Global Offset Table)** from being overwritten.  
There are three modes:

- **No RELRO** â†’ GOT is writable, attacker can overwrite function pointers (e.g., `printf` â†’ `system`).
- **Partial RELRO** â†’ GOT is still writable, but some sections are reordered to make exploitation harder.
- **Full RELRO** â†’ GOT is marked read-only after dynamic linking â†’ attacker cannot overwrite GOT.

ğŸ‘‰ Use: Prevents GOT overwrite attacks.

---

### ğŸ”¹ **PIE (Position Independent Executable)**

This makes the **binaryâ€™s code section load at a random address** each execution (like shared libraries).

- If **PIE disabled** â†’ binary loads at a fixed base address (exploits are easier, attacker knows addresses).
- If **PIE enabled** â†’ binary base address is randomized each run (ASLR fully effective).
ğŸ‘‰ Use: Makes return addresses & function addresses unpredictable.

---
### ğŸ”¹ **NX (No eXecute, aka DEP)**

Marks certain memory regions (stack, heap) as **non-executable**.
- If **NX disabled** â†’ attacker can inject shellcode into the stack and execute it.
- If **NX enabled** â†’ stack/heap cannot be executed â†’ attacker must use ROP/JOP instead of direct shellcode injection.
  it need to check chech whether the canary and the RIP is equal no not ??
ğŸ‘‰ Use: Stops classic stack-based shellcode execution.

## to know value of the canary

rax.OWORD PTR fs:0x28 when this line came, break the line and run it , it will give the value of the canary

## to find the address :
x fun_name;
it will return the address of the function


## why the %p leaks the memory address in case of the format string vulnerability :

this is the vuln code ,
char buf[100];
gets(buf);           // user input
printf(buf);         // âŒ VULNERABLE

here there is no format string specified to print , in such case we can give the %p%p like that , that will leak the one-by-one memory address from the stack


## In the format string vuln:

we can give the %x: or %34$x: too leak the memory , 

### What is a **syscall**?

A **syscall** (system call) is how a user program asks the operating system kernel to do something it canâ€™t do directly, like:

- Reading from a file
    
- Writing to stdout
    
- Allocating memory
    
- Creating a process
    

Instead of the program directly accessing hardware or privileged instructions, it calls `syscall`, which switches execution to the kernel.

On Linux (x86_64):

- The instruction `syscall` tells the CPU to enter kernel mode.
    
- The syscall number is stored in **RAX**.
    
- Arguments are passed in registers:
    
    - `RDI` â†’ 1st argument
        
    - `RSI` â†’ 2nd argument
        
    - `RDX` â†’ 3rd argument
        
    - `R10` â†’ 4th argument
        
    - `R8` â†’ 5th argument
        
    - `R9` â†’ 6th argument
        
- The return value comes back in **RAX**.

**what are the paramets are passed for write syscall:**

It has **3 parameters**:

1. **fd (file descriptor)** â†’ integer
    
    - `0` = stdin
        
    - `1` = stdout
        
    - `2` = stderr
        
    - Any other = open file/socket
        
2. **buf (buffer pointer)** â†’ pointer to the data you want to write
    
3. **count (size)** â†’ number of bytes to write