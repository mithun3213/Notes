
# What ‚Äúoffset‚Äù means (1 sentence)??

> **Offset = which numbered stack argument (`%N$‚Ä¶`) contains our input**


## to find the offset ??

Input this **exact payload**:

`AAAA %p %p %p %p %p %p %p %p %p %p`

üìå Explanation:

- Each `%p` prints **one stack slot**
    

## Observe the output

Example output (your values will differ):

`AAAA 0x7ffc1e8c2d80 0x7f1cfa0c0830 0x41414141 0x7ffc1e8c2e10 0x4006a0 ...`


0x41414141

That corresponds to "AAAA".

Let‚Äôs count:
Index	Output
1	0x7ffc1e8c2d80
2	0x7f1cfa0c0830
3	0x41414141 üëà


> **Offset = 3**

This means:

- Our input buffer starts at **argument #3**

--------

## C code:

```
int sum( int a, int b, int c )
{
    return a + b + c;
}

void main()
{
    int a = sum(10, 20, 30);
}
```

## Assembly Code (x86-64):

```
sum:
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-4], edi
    mov     DWORD PTR [rbp-8], esi
    mov     DWORD PTR [rbp-12], edx
    mov     edx, DWORD PTR [rbp-4]
    mov     eax, DWORD PTR [rbp-8]
    add     edx, eax
    mov     eax, DWORD PTR [rbp-12]
    add     eax, edx
    pop     rbp
    ret
```

```
main:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     edx, 30
    mov     esi, 20
    mov     edi, 10
    call    sum
    mov     DWORD PTR [rbp-4], eax
    nop
    leave
    ret
```
## The CPU stack

### The stack in the CPU is managed and affected by several registers.

SP ‚Äì stack pointer  
BP ‚Äì base pointer  
IP ‚Äì instruction pointer

  
Respectively the register names ESP, EBP, EIP are used in 32-bit (x86) systems, and RSP, RBP, RIP in 64-bit (x64) systems.  
The letter ‚ÄúE‚Äù before the name of the register in 32-bit systems stands for ‚ÄúExtended‚Äù.

The AMD64 ISA extension added 8 additional general-purpose registers, named R8 through R15. The 64-bit extended versions of the original 8 registers had an ‚ÄúR‚Äù prefix added to them for symmetry.

The RIP register (instruction pointer) points to the next instruction to be executed by the CPU.  
The RBP register (base pointer) points to the bottom (the beginning) of the stack.  
The RSP register (stack pointer) points to the top (the tip, or the end) of the stack.



- Programs **do not directly access RAM**
    
- Each program thinks it has its **own memory**
    
- The addresses it uses are **virtual addresses**
    
- The OS + CPU convert them into **physical addresses**
    

This conversion is done by the **MMU (Memory Management Unit)**


A **virtual address** is a **fake (logical) memory address** used by a program to access memory, instead of using the real physical RAM address.

--------

In a program‚Äôs memory layout, **heap and stack grow in opposite directions**:

- **Heap**
    
    - Used for dynamic memory (`malloc`, `new`)
        
    - **Grows upward** (towards higher addresses)
        
    - Example:
        
        - Starts at **1000**, size **200 bytes**
            
        - Occupies addresses **1000 ‚Üí 1200**
            
- **Stack**
    
    - Used for function calls, local variables
        
    - **Grows downward** (towards lower addresses)
        
    - The **Base Pointer (RBP)** starts at a **higher address than the heap**
        
    - Example:
        
        - RBP starts at **1300**
            
        - Stack grows down to **1200**
            
        - Stack size = **100 bytes**


-----


 ## **What is a Function Prologue**? 

A **function prologue** is the **set of instructions executed at the start of a function** to prepare a new **stack frame** for that function.

###  What does it do?

When a function is entered, the CPU needs space to:

- store **local variables**
    
- save important registers
    
- know where to **return** after the function ends
    

The function prologue sets this up.

When a function is called:

- The caller (e.g., `main()`) already has its **own stack frame**
    
- Its **RBP points to the bottom of that stack frame**
    
- When the callee (`sum()`) starts, it must **not lose this information**
    

So the CPU **saves the caller‚Äôs RBP on the stack**.

---

### üîç Step-by-step (your example)

Inside `main()`:

`RBP ‚Üí base of main() stack frame`

When `sum()` starts:

`push rbp     ; save main()'s RBP on the stack mov  rbp,rsp ; create sum()'s new stack frame`

Now on the stack:

`[ saved RBP of main() ]  ‚Üê this is the "old base pointer"`

This saved value allows:

- Returning safely to `main()`
    
- Restoring `main()`‚Äôs stack frame later
    

---

### On function return (epilogue)

`leave   ; mov rsp, rbp  +  pop rbp ret`

- `pop rbp` restores **main()‚Äôs original RBP**
    
- Execution continues correctly in the caller

-----

### What do these three instructions do?

```
mov DWORD PTR [rbp-4],  edi
mov DWORD PTR [rbp-8],  esi
mov DWORD PTR [rbp-12], edx
```

These instructions **store the function arguments into local stack variables**.

---

### üß† Context (x86-64 calling convention)

On **x86-64 (System V ABI)**:

- 1st argument ‚Üí `EDI`
    
- 2nd argument ‚Üí `ESI`
    
- 3rd argument ‚Üí `EDX`
    

In your C function:

`int sum(int a, int b, int c)`

- `a` ‚Üí `EDI`
    
- `b` ‚Üí `ESI`
    
- `c` ‚Üí `EDX`
    

---

### üîç What each line does

|Instruction|Meaning|
|---|---|
|`mov [rbp-4], edi`|Store `a` into local stack variable|
|`mov [rbp-8], esi`|Store `b` into local stack variable|
|`mov [rbp-12], edx`|Store `c` into local stack variable|

üìå Each uses **4 bytes** (`DWORD`) because `int` = 4 bytes.

-----------

## Function Epilogue

After doing its job, the function sum() prepares to return to its caller (the main() function).

This is called the Function Epilogue.  
The code that does that is the following:

add eax, edx  
pop rbp  
ret

The code ‚Äúadd eax, edx‚Äù adds the value of EDX to the value in EAX. EAX is the default register that holds data that a function will return. It is not a part of the function epilogue but I left it here to explain how functions return values. This explains why functions can return only a single value. If you like to return more than one value, you need to use a structure or pointers passed to the function as arguments. Higher-level languages like Python can disguise that, but it is what happens under the hood.  
  
After that, it pops the ‚Äúold‚Äù RBP from the stack, replacing the current value of RBP, which restores the previous ‚Äúbottom‚Äù of the stack frame (that belongs to main()).  
The ‚Äúret‚Äù instruction transfers control to the return address located on the stack (the RIP (instruction pointer)¬†pushed to the stack before calling the sum() function).

-------

## Why is the **Stack faster than the Heap?**


### Main reasons (in short)

1. **Preallocated memory**
    
    - Each thread gets a **fixed stack (‚âà 1 MB)** when it starts
        
    - No need to ask the OS for memory ‚Üí **instant access**
        
2. **No allocator overhead**
    
    - Stack variables don‚Äôt use `malloc/free`
        
    - Heap uses a **memory allocator** ‚Üí slow bookkeeping
        
3. **Very fast allocation & deallocation**
    
    - Stack allocates by **moving a pointer (RSP/RBP)**
        
    - Freeing is just moving it back
        
    - Heap must search, manage, and clean memory
        
4. **Compile-time addressing**
    
    - Stack variable addresses are **known at compile time**
        
    - Heap addresses are **found at runtime**
        
5. **Cache-friendly**
    
    - Stack variables are stored **next to each other**
        
    - CPU loads memory in **cache lines (64 bytes)**
        
    - One access loads nearby variables into **L1 cache** ‚Üí very fast

